# 代码

## 前转

首先我们考虑的是做xy坐标还是xz坐标(一个方向为垂直方向)，并写了`/demo/test.py`和`/demo/test-xz.py`发现xz方案的跳跃的手感（大跳和小跳），爬墙，重力系统等还是比较麻烦的，考虑到之后还会扩展许多东西，遂放弃。不过读者可以跑一下体验，支持跳跃和爬墙跳。

然后经过商议打算做泡泡堂。

首先是人物行动的是否只能在整数格上的问题。我们发现`/demo/test.py`人物在走入障碍围成的胡同（狭窄通道）时由于胡同的宽度和人物碰撞箱大小过于接近，难以对准，这当然可以通过缩小碰撞箱解决（但这样人物可以在胡同内侧向移动，但倒也没什么大不了的），不过我们当时决定人物只能在格子中央（相当在棋盘的黑白格子上）

考虑到人物只能在格子里走动，最开始的方案是大小帧方案（一个相当愚蠢的方案）：每个若干帧处理逻辑（大帧），其余帧只做渲染（小帧），人物在每两个大帧间移动一格，小帧来保证人物的移动是连续的。但是等笔者写完`/demo/demo.py`时才意识到一个严重的问题：人物不跟手。

`--|---(press)---|------------|---`$\tiny\text{竖线表示大帧}$

按下键盘的过程是在两个大帧之间完成的（如上图），那应该在第二个竖线处完成移动呢还是第三个呢？都不合适，一个会让运动不匀速一个会带来巨大延迟，取平衡的话会兼有两个缺点。读者可以自行尝试这垃圾的手感。

大小帧是行不通的。

不过这个方案的其他部分在最终的代码中得到了沿用，如存地图方式根据这个方案改成了二维数组套字典的方式，没有事件队列的entity-map架构（瞎起的名字，勿在意）

## 核心代码架构与设计概述

### entity-map架构

场地上所有能动的物品都为实体(entity)，所有不能动的物品作为格子存储在地图的二维数组中。

实体和实体之间不会直接发信息，而是通过地图类（`Mapper`）发信息。（某种意义上地图相当于起了部分事件队列的功能）这样函数调用在`entity`和`Mapper` 间回转（有点像二分图欸），一定程度上减少出现无限递归的概率。

- 比如说，实体完成自身的初始化之后调用构造函数(`__init__`)里的`initInMap`参数，在对应的地图类上进行初始化（如存到二维数组套字典中等）

然后原则上每个实体只修改自己的数据，不修改别的实体的数据，最好也不随便改地图的数据（有一部分没遵守，毕竟py好像没有 const 关键字，写着写着就忘了），如果想修改其他实体的数据，则尽量通过地图类调用其他实体的成员函数修改。这样做的目的是避免数据的混乱，不过在这个项目中好像也没有感觉出便利。

在每一帧中，依次调用`keyboard` `clock` `draw`事件。

- keyboard : 为catchKeyboard函数，将键盘输入按照当前玩家的状态分配到 `me.keyboard` 或 `dialoger.keyboard` ，它们根据键盘输入的信息进行预移动，切换对话上下文等。

- clock : 为 `me.clock`和`thisMap.clock`(其中在`thisMap.clock`又会调用地图中所有实体的clock成员函数)，它们将游戏推动到下一游戏时刻：进行entity的移动，炸弹爆炸等的计时，计时到0之后的处理等：大部分逻辑的处理都在这个阶段进行。(`dialog`类不需要clock，因为它按回车更新)

- draw ： 为`thisMap.draw`和`dialogger.draw`。它们渲染。`thisMap.draw`按照`camera`（镜头移动偏移量）等按照顺序从二维数组表示的图格中从左到右从上到下渲染（以便处理图片堆叠顺序）；`dialogger.draw` 绘制对话框。

**为啥不用事件队列？**

TODO

### 二维数组套字典的存图方式

由于所有实体实际上只能在格子里，无须复杂的碰撞体系，在加上在那啥中，二维数组是存储网格图的最常见方式，以及最开始看到的一个pygame小游戏也是以网格存图，所以理所当然的采用了按格子存储的方法。

所有

**为啥不用碰撞箱检测？**

当时也考虑了 “all in entity” 的方案，即所有的物品，包括可以动的实体和不可以动的障碍物全部使用pygame的矩形交判断所有碰撞，但最后没有采用采用。

### 代码的依赖关系

如图（暂无）

以下内容大多会在 _代码细节_ 中详述，这里主要将依赖关系。

`constants.py`存放常数与 Flag ，如帧率、默认血量、炸弹引爆时间等。

`imageclass.py` myImage类：我们以pygame的blit函数为基础封装了在多个方便的绘制函数。dialog类：提供了对话框的封装，可以方便的使用对话框。

`entity.py` 以imageclass为依托，实现了诸多entity类的各种功能，同时后半部分更为具体，功能更多的类由于需要频繁访问地图，虚线指向 scene.py
- `entity.py` 的后半部分代码以虚线指向 scene.py 表示“隐形”的依赖。观察 entity.py 中后半部分的函数，有很多成员函数的参数名叫mapper，它表示地图，但由于python的动态类型，无须import即可使用 scene.py 的内容，只是无法添加类型标注，这是从 entityLike 派生出的诸多类和 Mapper类耦合度大导致的，关于修改方法，见 _类型检查_ 一节。

`scene.py` 场景的各种函数，同样依托与渲染库 imageclass (主要是 myImage)，同时依赖 `entity.py` （主要是前半部分的 entity 和 creature ）。实现了场景（地图）的各种操作。

`inter.py` 本意为联合（雾），负责给 `entity.py` 和 `scene.py` 兜底。玩家虽也继承于实体（entityLike基类），但在这个文件里实现，因为玩家作为最复杂的实体，需要各种麻烦的操作（如检查键盘、捡东西、切换地图等）同时为main.py提供一些函数（如catchKeyboard）。音乐的播放在此。

`xxx_ai.py` 提供封装好的 llm 接口，直接调用其提供的函数与 llm 交互

`makescene.py` 储存每一张地图的信息，并提供生成地图函数。

`main.py` 主进程，包含主菜单，游戏主循环等

## 代码细节
TODO

## 类型检查

TODO

目前[type-test](https://github.com/segment-tree/SI100b-project/tree/type-test)分支为结构更清晰的代码，拆分了entity.py的前后部分(因为entity.py)后半部分mapper参数的类型为Mapper，其实依赖与scene.py但是因为python的动态类型是这个依赖可以不import，这样借助动态类型实现了类似于互相import，[这个commit](https://github.com/segment-tree/SI100b-project/commit/4eda9e9dfa4754ea69dc9b4110a3f6a173fa3ddf)可以看到拆分所做的一些修改，实际上地图部分和实体部分耦合度仍然较大，这也算是不使用事件队列只使用直接互调函数的缺点（entityLike和Mapper间函数互调，但entityLike不会直接发起对另一个entityLike的调用（而是通过地图发起），这保证了架构的稳定性）

## 性能分析

TODO